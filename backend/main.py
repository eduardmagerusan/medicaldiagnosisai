# -*- coding: utf-8 -*-
"""medicaldiagnosisai_backend.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nWgpQdnevumMxHVI8heeLPQYrwjO1KZP
"""

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

import tensorflow as tf
tf.compat.v1.disable_eager_execution()

from keras.preprocessing.image import ImageDataGenerator
from keras.applications.densenet import DenseNet121
from keras.layers import Dense, GlobalAveragePooling2D
from keras.models import Model
from keras import backend as K

from keras.models import Sequential
from keras.layers import Dense, Conv2D, MaxPool2D, Dropout, Flatten, BatchNormalization

from keras.models import load_model

from keras.preprocessing import image
from sklearn.metrics import classification_report
from sklearn.metrics import roc_auc_score, roc_curve
import random

import cv2

labels = ['Cardiomegaly', 
          'Emphysema', 
          'Effusion', 
          'Hernia', 
          'Infiltration', 
          'Mass', 
          'Nodule', 
          'Atelectasis',
          'Pneumothorax',
          'Pleural_Thickening', 
          'Pneumonia', 
          'Fibrosis', 
          'Edema', 
          'Consolidation']

random.seed(a=None, version=2)

def get_mean_std_per_batch(image_path, df, H=320, W=320):
    sample_data = []
    for idx, img in enumerate(df.sample(100)["Image"].values):
        # path = image_dir + img
        sample_data.append(
            np.array(image.load_img(image_path, target_size=(H, W))))

    mean = np.mean(sample_data[0])
    std = np.std(sample_data[0])
    return mean, std


def load_image(img, image_dir, df, preprocess=True, H=320, W=320):
    img_path = image_dir + img
    mean, std = get_mean_std_per_batch(img_path, df, H=H, W=W)
    x = image.load_img(img_path, target_size=(H, W))
    if preprocess:
        x -= mean
        x /= std
        x = np.expand_dims(x, axis=0)
    return x


def grad_cam(input_model, image, cls, layer_name, H=320, W=320):
    y_c = input_model.output[0, cls]
    conv_output = input_model.get_layer(layer_name).output
    grads = K.gradients(y_c, conv_output)[0]

    gradient_function = K.function([input_model.input], [conv_output, grads])

    output, grads_val = gradient_function([image])
    output, grads_val = output[0, :], grads_val[0, :, :, :]

    weights = np.mean(grads_val, axis=(0, 1))
    cam = np.dot(output, weights)
    cam = cv2.resize(cam, (W, H), cv2.INTER_LINEAR)
    cam = np.maximum(cam, 0)
    cam = cam / cam.max()
    return cam


def generate_gradcam(model, img, image_dir, df, labels, selected_labels,
                    layer_name='bn'):
    preprocessed_input = load_image(img, image_dir, df)
    predictions = model.predict(preprocessed_input)

    print("Loading original image")
    plt.figure(figsize=(15, 10))
    plt.subplot(151)
    plt.axis('off')
    plt.title("Original")
    plt.imshow(load_image(img, image_dir, df, preprocess=False), cmap='gray')

    j = 1
    for i in range(len(labels)):
        if labels[i] in selected_labels:
            print(f"Generating gradcam for class {labels[i]}")
            gradcam = grad_cam(model, preprocessed_input, i, layer_name)
            plt.subplot(151 + j)
            plt.title(f"{labels[i]}: p={predictions[0][i]:.3f}")
            plt.axis('off')
            plt.imshow(load_image(img, image_dir, df, preprocess=False),
                       cmap='gray')
            plt.imshow(gradcam, cmap='jet', alpha=min(0.5, predictions[0][i]))
            j += 1

train_df = pd.read_csv("/content/drive/MyDrive/Colab Notebooks/train.csv")
test_df = pd.read_csv("/content/drive/MyDrive/Colab Notebooks/test.csv")
image_dir = "/content/drive/MyDrive/Colab Notebooks/images/"

image_generator = ImageDataGenerator(
    featurewise_center=True,
    featurewise_std_normalization= True)

train = image_generator.flow_from_dataframe(
        dataframe=train_df,
        directory=image_dir,
        x_col="Image",
        y_col=labels,
        class_mode="raw",
        batch_size=8,
        shuffle=True,
        seed=1,
        target_size=(320, 320))

raw_train_generator = ImageDataGenerator().flow_from_dataframe(
    dataframe=train_df, 
    directory=image_dir, 
    x_col="Image", 
    y_col=labels, 
    class_mode="raw", 
    batch_size=100, 
    shuffle=True, 
    target_size=(320,320))

batch = raw_train_generator.next()
data_sample = batch[0]

image_generator.fit(data_sample)

test = image_generator.flow_from_dataframe(
    dataframe=test_df,
    directory=image_dir,
    x_col="Image",
    y_col=labels,
    class_mode="raw",
    batch_size=8,
    shuffle=False,
    seed=1,
    target_size=(320,320))

base_model = DenseNet121(weights='/content/drive/MyDrive/Colab Notebooks/densenet.hdf5', 
                         include_top=False)
x = base_model.output
x = GlobalAveragePooling2D()(x)
predictions = Dense(len(labels), activation="sigmoid")(x)
model = Model(inputs=base_model.input, outputs=predictions)
model.call = tf.function(model.call)

model.load_weights("/content/drive/MyDrive/Colab Notebooks/pretrained_model.h5")

predicted_vals = model.predict_generator(test, steps = len(test))

pd.DataFrame(classification_report(test.labels, predicted_vals > 0.5, output_dict=True, target_names=labels))

auc_roc_vals = []
for i in range(len(labels)):
  gt = test.labels[:, i]
  pred = predicted_vals[:, i]
  auc_roc = roc_auc_score(gt, pred)
  auc_roc_vals.append(auc_roc)
  fpr_rf, tpr_rf, _ = roc_curve(gt, pred)
  plt.figure(1, figsize=(10, 10))
  plt.plot([0, 1], [0, 1], 'k--')
  plt.plot(fpr_rf, tpr_rf,
            label=labels[i] + " (" + str(round(auc_roc, 3)) + ")")
  plt.xlabel('Falsch-Positiv')
  plt.ylabel('Richtig-Positiv')
  plt.title('ROC Kurve')
  plt.legend(loc='best')
plt.show()

df = pd.read_csv("/content/drive/MyDrive/Colab Notebooks/train.csv")

labels_to_show = np.take(labels, np.argsort(auc_roc_vals)[::-1])[:4]

generate_gradcam(model, '00000091_002.png', image_dir, df, labels, labels_to_show)

generate_gradcam(model, '00011355_002.png', image_dir, df, labels, labels_to_show)

generate_gradcam(model, '00006198_000.png', image_dir, df, labels, labels_to_show)

generate_gradcam(model, '00011217_000.png', image_dir, df, labels, labels_to_show)

generate_gradcam(model, '00011702_082.png', image_dir, df, labels, labels_to_show)
